<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Ngôn ngữ lập trình Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Giới thiệu</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Cài đặt</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><strong>2.</strong> Guessing Game Tutorial</li><li><strong>3.</strong> Common Programming Concepts</li><li><ul class="section"><li><strong>3.1.</strong> Variables and Mutability</li><li><strong>3.2.</strong> Data Types</li><li><strong>3.3.</strong> How Functions Work</li><li><strong>3.4.</strong> Comments</li><li><strong>3.5.</strong> Control Flow</li></ul></li><li><strong>4.</strong> Understanding Ownership</li><li><ul class="section"><li><strong>4.1.</strong> What is Ownership?</li><li><strong>4.2.</strong> References &amp; Borrowing</li><li><strong>4.3.</strong> Slices</li></ul></li><li><strong>5.</strong> Structs</li><li><ul class="section"><li><strong>5.1.</strong> Method Syntax</li></ul></li><li><strong>6.</strong> Enums</li><li><ul class="section"><li><strong>6.1.</strong> Option</li><li><strong>6.2.</strong> Match</li><li><strong>6.3.</strong> <code>if let</code></li></ul></li><li><strong>7.</strong> Modules</li><li><ul class="section"><li><strong>7.1.</strong> <code>mod</code> and the Filesystem</li><li><strong>7.2.</strong> Controlling Visibility with <code>pub</code></li><li><strong>7.3.</strong> Importing Names with <code>use</code></li></ul></li><li><strong>8.</strong> Fundamental Collections</li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><strong>8.2.</strong> Strings</li><li><strong>8.3.</strong> Hash Maps</li></ul></li><li><strong>9.</strong> Error Handling</li><li><ul class="section"><li><strong>9.1.</strong> Unrecoverable Errors with <code>panic!</code></li><li><strong>9.2.</strong> Recoverable Errors with <code>Result</code></li><li><strong>9.3.</strong> To <code>panic!</code> or Not To <code>panic!</code></li></ul></li><li><strong>10.</strong> Generics</li><li><ul class="section"><li><strong>10.1.</strong> Syntax</li><li><strong>10.2.</strong> Traits</li><li><strong>10.3.</strong> Lifetime syntax</li></ul></li><li><strong>11.</strong> Testing</li><li><ul class="section"><li><strong>11.1.</strong> Writing tests</li><li><strong>11.2.</strong> Running tests</li><li><strong>11.3.</strong> Test Organization</li></ul></li><li><strong>12.</strong> I/O</li><li><ul class="section"><li><strong>12.1.</strong> <code>Read</code> &amp; <code>Write</code></li><li><strong>12.2.</strong> <code>std::fs</code></li><li><strong>12.3.</strong> <code>std::path</code></li><li><strong>12.4.</strong> <code>std::env</code></li></ul></li><li><strong>13.</strong> Composition</li><li><ul class="section"><li><strong>13.1.</strong> Instead of Inheritance</li><li><strong>13.2.</strong> Trait Objects?</li></ul></li><li><strong>14.</strong> Creating a Library</li><li><ul class="section"><li><strong>14.1.</strong> Cargo</li><li><strong>14.2.</strong> Crates.io</li><li><strong>14.3.</strong> Organizing your Public API</li><li><strong>14.4.</strong> Documentation</li><li><strong>14.5.</strong> Workspaces and Multiple Related Crates</li></ul></li><li><strong>15.</strong> Closures</li><li><strong>16.</strong> Zero-cost Abstractions</li><li><ul class="section"><li><strong>16.1.</strong> Iterators as a Case Study</li></ul></li><li><strong>17.</strong> Smart Pointers</li><li><ul class="section"><li><strong>17.1.</strong> <code>Box&lt;T&gt;</code></li><li><strong>17.2.</strong> <code>Rc&lt;T&gt;</code></li><li><strong>17.3.</strong> <code>Cell</code></li><li><strong>17.4.</strong> <code>RefCell</code></li><li><strong>17.5.</strong> Interior Mutability</li></ul></li><li><strong>18.</strong> Concurrency</li><li><ul class="section"><li><strong>18.1.</strong> Threads</li><li><strong>18.2.</strong> <code>Send</code> &amp; <code>Sync</code></li><li><strong>18.3.</strong> <code>Arc&lt;T&gt;</code></li><li><strong>18.4.</strong> <code>Mutex&lt;T&gt;</code></li><li><strong>18.5.</strong> <code>Channels</code></li></ul></li><li><strong>19.</strong> Patterns</li><li><strong>20.</strong> More Lifetimes</li><li><strong>21.</strong> Unsafe Rust</li><li><ul class="section"><li><strong>21.1.</strong> Raw Pointers</li><li><strong>21.2.</strong> <code>transmute</code></li></ul></li><li><strong>22.</strong> Foreign Function Interface</li><li><ul class="section"><li><strong>22.1.</strong> Conditional Compilation</li><li><strong>22.2.</strong> Bindings to C</li><li><strong>22.3.</strong> Using Rust from Other Languages</li><li><strong>22.4.</strong> <code>static</code></li></ul></li><li><strong>23.</strong> Advanced Type System Features</li><li><ul class="section"><li><strong>23.1.</strong> Associated Types</li><li><strong>23.2.</strong> Trait Objects</li><li><strong>23.3.</strong> UFCS</li><li><strong>23.4.</strong> Coherence</li></ul></li><li><strong>24.</strong> Macros</li><li><ul class="section"><li><strong>24.1.</strong> Writing Your Own Macros</li></ul></li><li><strong>25.</strong> Nightly Rust</li><li><ul class="section"><li><strong>25.1.</strong> Nightly Features</li><li><strong>25.2.</strong> How to Find Out About Nightly Features</li></ul></li><li><strong>26.</strong> Appendix</li><li><ul class="section"><li><strong>26.1.</strong> Keywords</li><li><strong>26.2.</strong> Operators</li><li><strong>26.3.</strong> Derivable Traits</li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Ngôn ngữ lập trình Rust</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Giới thiệu</h1>
<p>Đây là quyển sách cơ bản về Rust, quyển sách này được dịch từ phiên bản <a href="https://rust-lang.github.io/book/">Tiếng Anh</a>.
Rust là một ngôn ngữ lập trình tập trung vào độ an toàn, nhanh và đồng thời. Rust được thiết kế
để xây dựng một chương trình mang hiệu suất cao và được điều khiển như những ngôn ngữ bậc thấp khác,
nhưng lại đảm bảo tính abstraction như những ngôn ngữ lập trình bậc cao khác.
Những tính năng này rất phụ hợp với những lập trình viên đã có nền tảng trên C/C++ và muốn
tìm một ngôn ngữ an toàn hơn để thay thế, cũng như những lập trình viên sử dụng các ngôn ngữ khác như
Python muốn tìm cách viết code chạy nhanh hơn mà không cần phải hi sinh sự dễ đọc của code.</p>
<p>Rust thực hiện việc kiểm tra chính về độ an toàn và quản lý vùng nhớ trong quá trình biên dịch,
do đó hạn chế được các lỗi xảy ra trong khi thực hiện chương trình. Điều này đã làm cho Rust có một
số đặc điểm nổi trội so với các ngôn ngữ khác: chương trình với những yêu cầu đòi hỏi dự đoán được bộ nhớ và thời gian thực thi, được gọi từ ngôn ngữ khác, code viết được dưới dạng bậc thấp nên chúng ta có thể viết được các device drivers, hệ điều hành. Rust cũng được dùng cho các ứng dụng web: đa dạng và phong phúc các gói ứng dụng của Rust tại <a href="https://crates.io/">crates.io</a>!.</p>
<p>Quyển sách này được viết dành cho những những đã biết ít nhất một ngôn ngữ. Sau khi đọc xong quyển sách này,
bạn sẽ viết được ngôn ngữ Rust 1 cách thoải mái. Chúng ta sẽ cùng nhau học Rust đi từ những bước nhỏ nhất,
tập trung hơn vào các ví dụ thực tế được xây dựng trên Rust để hiểu rõ về Rust hoạt động như thế nào.</p>
<h2>Đóng góp vào quyển sách này</h2>
<p>Quyển sách này là mã nguồn mở. Được dịch lại từ <a href="https://rust-lang.github.io/book/">bản chính</a>. Nếu bạn tìm thấy lỗi nào về cú pháp,
hoặc cách dùng từ không đúng, hoặc bạn tìm ra lỗi nào đó, thì đừng do dự điều gì nửa,
hãy gửi một pull request <a href="https://github.com/rust-vietnam/book/pulls">trên Github</a>.</p>
<h2>Cài đặt</h2>
<p>Bước đầu tiên đề dùng được Rust là bạn phải cài đặt nó, yêu cầu
máy tính của bạn phải được kết nối với internet.</p>
<p>Tất cả các bước dưới đây đoều sử dụng terminal, các dòng lệnh điều bắt đầu bằng <code>$</code>.
Bạn không cần phải gõ lại <code>$</code>, ký hiệu này cho biết bắt đầu một dòng lệnh. <code>$</code> chạy dưới quyền
người dùng bình thường, còn <code>#</code> chạy dưới quyền quản trị cao nhất.</p>
<h3>Cài đặt trên hệ điều hành Linux và Mac (unix)</h3>
<p>Khi bạn dùng Linux hoặc Mac, bạn cần mở terminal lên và gõ lệnh sau:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Dòng lệnh trên sẽ thực hiện các công việc cần thiết đề cài Rust vào máy của bạn,
trong quá trình cài bạn cần nhập mật khẩu. Nếu không có lỗi gì xảy ra thì bạn
sẽ nhận được nội dung như dưới đây:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<h3>Cài đặt trên Windows</h3>
<p>Khi dùng Windows, truy cập địa chỉ <a href="https://rustup.rs/">https://rustup.rs</a><!-- ignore --> và làm theo
các hướng dẫn để tải về <code>rustup-init.exe</code>. Chạy file <code>rustup-init.exe</code> và làm theo các hướng dẫn.</p>
<p>Đôi với những hướng dẫn cho phiên bản Windows điều dùng <code>cmd</code> để thực hiện các thao tác dòng lệnh
. Nếu bạn dùng những loại shell khác bạn phải thực hiện các thao tác tường tự trên Mac và Linux.</p>
<h3>Cài đặt tuỳ chỉnh</h3>
<p>Nếu bạn muốn tuỳ chỉnh trong quá trình cài đặt Rust thì tham khảo tại <a href="https://www.rust-lang.org/install.html">Các tuỳ chỉnh khi cặt đặt Rust</a>.</p>
<h3>Gỡ cài đặt</h3>
<p>Việc gỡ cài đặt Rust cũng đơn giản như cài đặt vậy. Từ termial gõ:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<h3>Xử lý khi gặp phải vấn đề</h3>
<p>Nếu bạn đã cài Rust, thì gõ lệnh sau:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>Bạn sẽ thấy phiên bản, mã commit, và và ngày commit như là ví dụ phiên bản ví dụ dưới:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>Nếu bạn nhìn thấy dòng trên, thì chúc mừng bạn đã cài đặt Rust thành công!</p>
<p>Bạn là người dùng Window và bạn không thấy được như trên thì kiểm tra lại Rust
đã tồn trong biến môi trường <code>%PATH%</code> chưa.</p>
<p>Nếu bạn đã làm tất cả những bước trên nhưng vẫ không giải quyết được vấn đề thì dưới đây
là một số nơi có thể giúp bạn giải quyết được vấn đề.
Vào kênh Rust ở IRC <a href="irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a><!-- ignore -->,
thông qua <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Bạn sẽ tìm các Rustaceans để giúp bạn. Một nơi tốt khác là
<a href="https://users.rust-lang.org/">Diễn đàn</a> và <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>. Nếu ở Việt nam bạn có thể tham gia vào <a href="http://groups.rust-lang.vn">Google groups</a></p>
<h3>Tài liệu</h3>
<p>Khi cài đặt thì Rust sẽ mặc định sẽ sinh ra cho bạn những tài liệu cần thiết.
Gõ <code>rustup doc</code> để xem tài liệu trên trình duyệt.</p>
<p>Bạn có thể tra cứu bất kỳ API nào về các thư viện chuẩn.</p>
<h2>Hello, world</h2>
<p>Khi đã cài Rust xong, bước tiếp theo là viết một chương trình đơn giản.
Cách truyền thống để học một ngôn ngữ mới là in ra dòng chữ &quot;Hello, world!&quot; ở màn hình,
trong phần này, chúng ta sẽ học theo cách truyền thống đó.</p>
<blockquote>
<p>Ghi chú: Bạn cần có chút kiến thức về command line và bạn có thể chọn bất cứ
công cụ nào để lập trình Rust.</p>
</blockquote>
<h3>Tạo project</h3>
<p>Bạn có thể không cần phải tạo project, nhưng chúng tôi đề nghị bạn nên tạo nó,
để thuận tiện cho việc quản lý code, Rust không quan tâm việc bạn đặt code ở đâu.
Mở terminal và làm theo các bước để tạo một project:</p>
<p>Linux và Mac:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; mkdir %USERPROFILE%\projects
&gt; cd %USERPROFILE%\projects
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3>Bắt đầu viết chương trình đầu tiên</h3>
<p>Tạo một file mới đặt tên là <em>main.rs</em>. File Rust luôn luôn có phần đuôi là <em>rs</em>.
Nếu bạn muốn đặt tên file với nhiều từ thì dùng <code>_</code> để tách chúng.
Ví dụ bạn đặt tên file là <em>hello_world.rs</em> hơn là <em>helloworld.rs</em>.</p>
<p>Bạn mở file <em>main.rs</em> và thêm đoạn code sau:</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Lưu file và quay trở lại cửa sổ dòng lệnh. Đối với Linux và Mac, thực hiện lệnh sau :</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>Đối với Window, thay <code>./main</code> bằng <code>.\main.exe</code>. Không phụ thuộc vào hệ điều hành của bạn, bạn sẽ thấy
dòng chữ <code>Hello, world!</code> được hiện ra ở terminal. Nếu bạn làm được điều đó, xin chúc mừng!
Bạn đã viết được một chương trình ở Rust rồi đấy. Điều đó đã làm cho bạn trở thành
một Rust programmer, haha.</p>
<h3>Cấu trúc của một chương trình Rust</h3>
<p>Bây giờ chúng ta sẽ cùng phân tích cấu trúc của một chương trình Rust sẽ bao gồm những gì.
Hãy nhìn những dòng code dưới đây:</p>
<pre><code class="language-rust">fn main() {

}
</code></pre>
<p>Đây là những dòng code định nghĩa một <em>functions</em> ở Rust. Hàm <code>main</code> là một hàm đặc biệt: nó là hàm
chạy đầu tiên đối với các chương trình dạng <em>executable</em>. Dòng đầu tiên chỉ ra rằng
, “Tôi khai báo một hàm tên là <code>main</code>, hàm này không nhận bất kỳ tham số nào
và không có return lại data.” Nếu có thêm tham số, thì các tham số này phải được đặt trong,
<code>(</code> và <code>)</code>.</p>
<p>Phần xử lý của một function phải được đặt trong cặp dấu, <code>{</code> và <code>}</code>. Để được xem như một hàm tốt về mặt trình bày
thì dấu <code>{</code> phải được đặt cùng hàng với tên hàm, và có một khoản cách giữa tên hàm và <code>{</code>.</p>
<p>Trong hàm <code>main</code>:</p>
<pre><code class="language-rust">    println!(&quot;Hello, world!&quot;);
</code></pre>
<p>Với một chương trình đơn giản thì dòng code trên đã chứa đừng hết nội dùng của chương trình, cụ thể:
Nó in ra dòng text ở màn hình. Ở đây có một vài điểm lưu ý. Đầu tiên, nói về mặt coding style thì Rust dùng
<code>tab space</code> để thụt vào, không dùng <code>tab</code>.</p>
<p>Điều quan trọng thứ 2 là <code>println!</code>. Đây được gọi là <em>macro</em> ở Rust. Nếu gọi đây là một hàm,
thì nó sẽ giống như vầy: <code>println</code> (không có <code>!</code>). Chúng ta sẽ quay trở lại thảo luận về <em>macro</em> ở chương 24,
nhưng ở thời điểm hiện tại thì bạn nên hiểu là nếu bạn thấy <code>!</code> nghĩa là bạn đang gọi một <em>macro</em> hơn là một function.</p>
<p>Kế tiếp là <code>&quot;Hello, world!&quot;</code>, đây là một <em>string</em>. Chúng ta truyền chuỗi này như là một tham số cho <code>println!</code>,
để in ra dòng text trên màn hình. Quá đơn giản!</p>
<p>Chúng ta sẽ kết thúc một dòng code bằng (<code>;</code>). <code>;</code> để chỉ ra rằng dòng lệnh này đã kết thúc,
dòng lệnh kế tiếp sẽ được thực thi. Hầu hết để kết thúc dòng lệnh ở Rust ta dùng <code>;</code>.</p>
<h3>Biên dịch và chạy chương trình</h3>
<p>Trong phần trước chúng ta đã biết cách tạo một project đơn giản.
Kế tiếp chúng ta lần lượt tìm hiểu các bước đơn giản để biện dịch một chương trình ở Rust.</p>
<p>Trước khi chạy được chương trình Rust, bắt buộc ta phải biên dịch nó. Bạn có thể dùng công cụ compiler
của Rust (<code>rustc</code>) và thực hiện dòng lệnh như dưới đây:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>Nếu bạn đã từng làm việc với <code>C</code> hoặc <code>C++</code> thì nó tương tự với
<code>gcc</code> hoặc <code>clang</code>. Sau khi biên dịch thành công, Rust sẽ output ra một file binary
executable, đối với Linux hoặc Mac bạn có thể dùng câu lệnh <code>ls</code> ở shell như dòng code dưới:</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>Nếu dùng Windows:</p>
<pre><code class="language-cmd">&gt; dir /B %= (Tuỳ chọn /B chỉ hiển thị tên file)
main.exe
main.rs
</code></pre>
<p>Cách trên sẽ hiện thị cho chúng ta thấy được 2 file: source code, có đuôi mở rộng là <em>.rs</em>, và
chương trình thực hiện(<em>main.exe</em> đối với Windows, <em>main</em> đối với các hệ điều hành khác).
Các công việc cần làm bây giờ là chạy file <em>main</em> hoặc <em>main.exe</em>, giống như cách dưới đây:</p>
<pre><code class="language-text">$ ./main  # hoặc .\main.exe đối với windows
</code></pre>
<p>Nếu trong file <em>main.rs</em> chương trình của bạn in ra dòng chữ là &quot;Hello, world!&quot;, thì bạn sẽ thấy
dòng chữ <code>Hello, world!</code> ngay trên terminal của bạn.</p>
<p>Nếu bạn đã từng biết qua Ruby, Python, hoặc JavaScript, bạn không phải làm các bước compile cực khổ này.
Rust là một ngôn ngữ có đặc điểm <em>ahead-of-time compiled</em>, nghĩa là bạn có thể compile một chương trình,
và đưa nó qua một môi trường khác, và bạn có thể chạy chương trình đó mà không phải phụ thuộc vào việc đã cài đặt
Rust hay chưa. Nếu bạn copy các file <code>.rb</code>, <code>.py</code>, hoặc <code>.js</code>, sang một môi trường khác,
thì cần phải có Ruby, Python, hoặc JavaScript phải được cài đặt,
nhưng bạn chỉ cần một dòng lệnh cho cả việc compile và chạy chương trình.
Tất cả mọi thứ điều có một sự lựa chọn phụ hợp khi thiết kế ngôn ngữ đó.</p>
<p>Dùng <code>rustc</code> để compile đối với những chương trình đơn giản là một lựa chọn hợp lý, nhưng khi chương trình
phức tạp, bạn muốn quản lý các tuỳ chỉnh của chương trình và muốn công việc chia sẽ với người khác
trở nên đơn giản hơn. Phần kế tiếp chúng ta sẽ cùng tìm hiểu về một công cụ gọi là Cargo, và chúng ta sẽ dùng
tool này để viết một chương trình đơn giản <code>Hello, world!</code>.</p>
<h2>Xin chào, Cargo!</h2>
<p>Cargo là một công cụ dùng để quản lý các gói và là một công cụ dùng để build các chương trình của Rust,
và Rustaceans sử dụng Cargo để quản lý các project vì đặc điểm dể sử dụng. Ví dụ,
Cargo được dùng để build code, tự động tải về các thư viện cần thiết, và tiến hành compile các thư viện đó.
Chúng ta gọi các thư viện phụ thuộc vào code là <em>dependencies</em>.</p>
<p>Chương trình đơn giản nhất ở Rust, giống như chương trình chúng ta đã xây dựng ở phần trên, không có
bất kỳ dependencies nào, cho nên, chúng ta chỉ sử dụng một phần chức năng của Cargo để xây dựng chương trình.
Nhưng khi bạn viết một chương trình phức tạp, bạn sẽ cần add thêm nhiều dependencies, và nếu bạn dùng Cargo,
điều đó thật đơn giản để thực hiện.</p>
<p>Phần lớn những chương trình viết bằng Rust sử dụng Cargo, nên chúng tôi mặc định bạn sẽ dùng Cargo trong suốt quá trình
còn lại. Cargo sẽ được cài mặc định trong quá trình cài Rust, nếu như bạn làm theo các bước hướng dẫn cài đặt ở phần Cài đặt.
Nếu bạn cài đặt Rust theo một cách khác nào đó, bạn có thể kiểm tra lại Cargo đã được cài đặt hay chưa bằng dòng lệnh dưới đây:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>Nếu bạn thấy được phiên bản của Cargo, thật tuyệt vời! Nếu bạn thấy <code>command not found</code>, kế tiếp bạn cần làm theo các bước hướng dẫn ở phần cài đặt để cài Cargo.</p>
<h3>Tạo project với Cargo</h3>
<p>Bây giờ chúng ta sẽ cùng tạo một project bằng Cargo và so sánh sự khác biệt với project <code>hello_world</code> lúc trước.
Trở lại thư mục projects (hoặc bất kỳ thư mục nào bạn muốn đặt code):</p>
<p>Linux và Mac:</p>
<pre><code class="language-text">$ cd ~/projects
</code></pre>
<p>Windows:</p>
<pre><code class="language-cmd">&gt; cd %USERPROFILE%\projects
</code></pre>
<p>Và trên mọi hệ điều hành chạy dòng lệnh:</p>
<pre><code class="language-text">$ cargo new hello_cargo --bin
$ cd hello_cargo
</code></pre>
<p>Chúng ta truyền thêm tham số <code>--bin</code> đối với <code>cargo new</code> bởi vì mục chúng ta muốn tạo chương trình dạng
executable, hơn là tạo một thư viện. Các file executable hay còn được gọi là <em>binaries</em>.
Chúng ta đặt tên project là <code>hello_cargo</code>, và Cargo sẽ tạo các file trong thư mục cùng tên với tên project.</p>
<p>Nếu chúng ta mở thư muc <em>hello_cargo</em>, chúng ta sẽ thấy Cargo sẽ tự động tạo 2 files và một thư muc:
file <em>Cargo.toml</em> và thư mục <em>src</em> chứa file <em>main.rs</em>. Cargo cũng sẽ khơi tạo thư mục git trong thư mục
<em>hello_cargo</em>, cùng với file <em>.gitignore</em>; bạn có thể thay đổi phần quản lý source (source version control),
hoặc giữ mặc định bằng cách sử dụng tuỳ chọn <code>--vcs</code>.</p>
<p>Mở file <em>Cargo.toml</em> bằng một công cụ chỉnh sửa text. Bạn sẽ nhìn thấy nội dụng file như dưới đây:</p>
<p><span class="filename">Tên file: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</code></pre>
<p>File này có định dạng <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (Tom's Obvious, Minimal
Language). TOML giống như INI nhưng có thêm một số tính năng mới và được dùng
như là format của các cấu hình trong Cargo.</p>
<p>Dòng đầu tiên, <code>[package]</code>, là tiêu đề của các cấu hình project. Chúng ta sẽ quay trở lại kỹ hơn
nhưng phần này trong chương sau.</p>
<p>Những dòng kế tiếp là thông tin cấu hình của project.</p>
<p>Dòng cuối cùng là, <code>[dependencies]</code>, quy định các gói được dùng trong chương trình.</p>
<p>Nhìn file <em>src/main.rs</em>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Cargo sẽ tự động sinh ra cho ta đoạn code trên, nó giống như những dòng code chúng ta đã viết lúc trước!
Sự khác nhau giữ project dùng Cargo và chúng ta tự khởi tạo:</p>
<ul>
<li>Code được đặt trong thư mục <em>src</em>.</li>
<li>File <em>Cargo.toml</em> chứa tất cả các cấu hình cho project.</li>
</ul>
<h3>Building và Running một project Cargo</h3>
<p>Thực hiện dòng lệnh dưới đây:</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
</code></pre>
<p>Dòng lệnh này sẽ tự động tạo cho chúng ta một file executable <em>target/debug/hello_cargo</em> (hoặc
<em>target\debug\hello_cargo.exe</em> ở Windows), bạn có thể chạy file đó ở terminal:</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # hoặc .\target\debug\hello_cargo.exe ở Windows
Hello, world!
</code></pre>
<p>Bam! Chúng ta sẽ thấy dòng chữ <code>Hello, world!</code> ở terminal.</p>
<p>Chúng ta vừa build project bằng cách dùng <code>cargo build</code> và chạy nó bằng
<code>./target/debug/hello_cargo</code>, nhưng chúng ta có thể dùng dòng lệnh <code>cargo run</code> để compile và run:</p>
<pre><code class="language-text">$ cargo run
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Chúng ta thấy một số điểm khác biệt ở đây:</p>
<ul>
<li>Thay vì dùng <code>rustc</code>, build project bằng cách dùng <code>cargo build</code> ( hoặc build và run bằng <code>cargo run</code>).</li>
<li>Thay vì output kết quả cùng với thư mục hiện tại thì Cargo sẽ output ở thư mục <em>target/debug</em>.</li>
</ul>
<p>Điểm đặc biệt là khi dùng Cargo chúng ta không phải quan tâm đến hệ điều hành đang dùng là gì.</p>
<blockquote>
<p>Chú ý: Nếu bạn muốn tìm hiểu chi tiết về cách dùng của Cargo thì tham khảo tại
<a href="http://doc.crates.io/guide.html">Cargo guide</a>, chứa đầy đủ các hướng dẫn về Cargo.</p>
</blockquote>
<h2>Vectors</h2>
<p>Kiểu dữ liệu đầu tiên mà chúng ta tìm hiểu là <code>Vec&lt;T&gt;</code>, còn gọi là <em>vector</em>. Vector
sẽ cho phép chúng ta lưu trữ nhiều hơn một giá trị trong một cấu trúc dữ liệu bằng cách
xếp tất cả các giá trị nằm liền kề nhau trong bộ nhớ. Vector chỉ có thể lưu trữ dữ liệu
của cùng 1 kiểu. Nó rất hữu dụng trong tình huống bạn có một loạt các phần tử, chẳng hạn
như các dòng chuỗi (line of string) trong một file, hoặc giá của từng món hàng trong một cái
giỏ hàng.</p>
<h3>Tạo mới một Vector</h3>
<p>Để tạo mới một vector rỗng, chúng ta có thể gọi hàm <code>Vec::new</code>:</p>
<pre><code class="language-rust">let v: Vec&lt;i32&gt; = Vec::new();
</code></pre>
<p>Lưu ý rằng chúng ta để chỉ định kiểu (type annotation) ở đây. Bởi vì chúng ta không
nhét (insert) gì vào vector này, Rust không biết kiểu phần tử mà chúng ta dự định
lưu là gì. Đây là một điểm quan trọng. Vector là đồng nhất: chúng có thể lưu trữ
nhiều giá trị, nhưng những giá trị đó phải là cùng 1 kiểu dữ liệu. Vector được
cài đặt (implemented) sử dụng Generics, sẽ được tìm hiểu sau ở chương 10 để dùng
cho kiểu dữ liệu của chính chúng ta. Bây giờ, tất cả những gì bạn cần biết là kiểu
<code>Vec</code> được cung cấp bởi thư viện chuẩn (standard library) có thể giữ được bất kì kiểu
dữ liệu nào, và khi muốn chỉ định kiểu dữ liệu cho <code>Vec</code> thì chúng ta đưa kiểu dữ liệu
của nó vào bên trong ngoặc <code>&lt;&gt;</code>. Trong ví dụ trên, chúng ta đã báo với Rust là <code>Vec</code>
<code>v</code> sẽ giữ những phần tử thuộc kiểu <code>i32</code>.</p>
<p>Trong code thực tế, Rust có thể suy luận ra kiểu dữ liệu chúng ta muốn lưu trữ
một khi chúng ta <code>insert</code> giá trị vào, nên rất hiếm khi bạn phải chỉ định kiểu.
Trong code cũng thường có những lúc chúng ta muốn khởi tạo những giá trị ban đầu
cho <code>Vec</code>, Rust cung cấp cho chúng ta macro <code>vec!</code> để làm chuyện này một cách tiện
lợi hơn. Macro này sẽ tạo một <code>Vec</code> mới và đưa vào những giá trị mà chúng ta cũng
cấp cho nó. Ví dụ sau đây sẽ tạo mới một <code>Vec&lt;i32&gt;</code> mà giữ những phần tử <code>1</code>, <code>2</code>,
và <code>3</code>:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3];
</code></pre>
<p>Vì chúng ta đưa vào những giá trị <code>i32</code> ban đầu, Rust có thể suy luận ra kiểu
dữ liệu của <code>v</code> là <code>Vec&lt;ì&gt;</code>, và chỉ định kiểu là không cần thiết. Tiếp theo hãy
cùng xem cách để thay đổi 1 vector.</p>
<h3>Thay đổi một Vector</h3>
<p>Để tạo ra một vector và thêm phần tử vào nó, chúng ta có thể dùng hàm <code>push</code>:</p>
<pre><code class="language-rust">let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
</code></pre>
<p>Giống như bất kì biến nào mà chúng ta đã thảo luận trong Chương 3, nếu chúng ta muốn
thay đổi giá trị của chúng, chúng ta phải khai báo nó thay đổi được bằng từ khoá
<code>mut</code>. Những số chúng ta cho vào đều là <code>i32</code>, và Rust suy luận được điều này từ data,
nên chúng ta không cần phải khai báo kiểu <code>Vec&lt;i32&gt;</code>.</p>
<h3>Giải phóng một Vector sẽ giải phóng những phần tử của nó</h3>
<p>Giống như bất kì <code>struct</code> nào khác, vector sẽ được giải phóng khi nó ra khỏi phạm vi:</p>
<pre><code class="language-rust">{
    let v = vec![1, 2, 3, 4];

    // làm gì đó với v

} // &lt;- v ra khỏi phạm vi và bị giải phóng ở đây.
</code></pre>
<p>Khi vector bị giải phóng, tất cả nội dung của nó cũng sẽ bị giải phóng, có nghĩa
những số nguyên nó lưu giữ cũng bị dọn dẹp. Bạn thấy có vẻ rất dễ hiểu ở đây,
nhưng nó có thể trở nên phức tạp hơn một chút khi chúng ta bắt đầu cho tham chiếu
vào thành phần tử của vector. Hãy cùng giải quyết vấn đề đó tiếp theo!</p>
<h3>Đọc phần tử của Vector</h3>
<p>Bây giờ bạn đã biết cách để khởi tạo, thay đổi, và giải phóng vector, bước tiếp
theo sẽ là biết cách để đọc nội dung của nó. Có 2 cách để tham chiếu một giá trị
được lưu trữ trong vector. Trong những ví dụ, chúng ta sẽ khai báo kiểu dữ liệu
của các giá trị được trả về từ các hàm để dễ đọc hơn.</p>
<p>Ví dụ sau đây sử dụng cả 2 cách để truy cập dữ liệu trong 1 vector là dùng cú pháp
chỉ mục hoặc dùng hàm <code>get</code>:</p>
<pre><code class="language-rust">let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
let third: Option&lt;&amp;i32&gt; = v.get(2);
</code></pre>
<p>Có vài điều cần lưu ý ở đây. Đầu tiên, chúng ta sử dụng giá trị chỉ mục <code>2</code> để
lấy ra phần tử thứ 3: Vector được đánh chỉ mục bằng số, bắt đầu bằng 0.
Thứ 2, hai cách khác nhau để lấy phần tử thứ 3 là: sử dụng <code>&amp;</code> và <code>[]</code> sẽ trả về
cho chúng ta một tham chiếu, hoặc sử dụng hàm <code>get</code> với chỉ mục được truyền vào
tham số sẽ trả về cho chúng ta kiểu <code>Option&lt;&amp;T&gt;</code>.</p>
<p>Lý do Rust có 2 cách để tham chiếu 1 phần tử là để bạn có thể cách mà chương trình
hoạt động khi bạn thử sử dụng 1 giá trị chỉ mục mà Vector không có phần tử tại đó.
Để ví dụ, chương trình sẽ làm gì nếu nó có 1 vector giữ 5 phần tử và thử truy xuất
phần tử tại chỉ mục 100 như sau:</p>
<pre><code class="language-rust,should_panic">let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
</code></pre>
<p>Khi bạn chạy chương trình này, bạn sẽ thấy là với hàm <code>[]</code> đầu tiên, Rust sẽ
bị <code>panic!</code> khi phần tử không tồn tại được truy xuất. Hàm này nên được dùng
nếu bạn muốn chương trình của mình xem việc truy xuất phần tử sau phần tử cuối
cùng của vector là nguy hiểm và cần phải crash chương trình ngay lập tức.</p>
<p>Khi hàm <code>get</code> được truyền vào chỉ mục nằm ngoài mảng, nó sẽ trả về <code>None</code> và
không bị <code>panic!</code>. Bạn nên xài nó nếu việc truy cập phần tử ngoài mảng là thường
xuyên xảy ra trong trường hợp bình thường. Code của bạn phải có logic để xử lý
hoặc có <code>Some(&amp;element)</code> hoặc <code>None</code>, như chúng ta đã thảo luận trong Chương 6.
Ví dụ, chỉ mục có thể đến từ người dùng nhập vào 1 số. Nếu họ lỡ nhập nhầm 1 số
quá lớn vào chương trình của bạn trả ra <code>None</code>, bạn có thể báo với người dùng có
bao nhiêu phần tử đang ở trong mảng và cho họ cơ hội khác để nhập vào giá trị
đúng. Việc đó sẽ thân thiện với người dùng hơn là chương trình crash ngay mỗi khi
nhập nhầm 1 số nào đó!</p>
<h4>Tham chiếu không hợp lệ</h4>
<p>Một khi chương trình có tham chiếu hợp lệ, borrow checker sẽ thi hành những luật
ownership và borrowing đã được thảo luận trong Chương 4 để đảm bảo tham chiếu này
và bất kì những tham chiếu nào khác đến nội dụng của vector đều ở trang thái hợp lệ.
Nhắc lại luật nói rằng chúng ta không thể có tham chiếu thay đổi và tham chiếu chỉ đọc
trong cùng 1 phạm vi (scope). Luật đó cũng áp dụng trong ví dụ sau đây, khi chúng ta
giữ một tham chiếu chỉ đọc tới phần tử đầu tiên trong mảng và thử cho thêm phần tử vào
cuối mảng:</p>
<pre><code class="language-rust,ignore">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);
</code></pre>
<p>Biên dịch chương trình này sẽ đưa ra lỗi sau:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
  |
4 | let first = &amp;v[0];
  |              - immutable borrow occurs here
                 - mượn tham chiếu chỉ đọc ở đây
5 |
6 | v.push(6);
  | ^ mutable borrow occurs here
      mượn tham chiếu thay đổi ở đây
7 | }
  | - immutable borrow ends here
      tham chiếu chỉ đọc kết thúc ở đây
</code></pre>
<p>Đoạn code trên nhìn có vẻ nó nên hoạt động được: tại sao tham chiếu tới phần tử
đầu tiên lại quan tâm tới thay đổi ở cuối của mảng? Lý do code này không hoạt động
là vì cách vector hoạt động. Thêm phần tử mới vào cuối vector có thể cần phải
cấp phát 1 phần bộ nhớ mới và copy những phần tử cũ lên vùng nhớ mới, trong trường
hợp khi đã không còn đủ bộ nhớ để nhét tất cả các phần tử liền kề nhau nữa. Trong
trường hợp đó, tham chiếu tới phần tử đầu tiên có thể là chỉ tới 1 vùng nhớ đã bị
giải phóng. Luật mượn tham chiếu đã ngăn cản chương trình không bị rơi vào trường
hợp đó.</p>
<blockquote>
<p>Ghi chú: Để biết thêm thông tin về vấn đề này, hãy xem [The Nomicon][nomicon].
[nomicon]: https://doc.rust-lang.org/stable/nomicon/vec.html</p>
</blockquote>
<h3>Sử dụng Enum để Lưu nhiều kiểu dữ liệu</h3>
<p>Vào đầu chương này, chúng ta đã nghiên cứu là vector chỉ có thể lưu trữ giá trị
mà có cùng một kiểu dữ liệu. Điều này có thể gây khó chịu, chắc chắn sẽ có những
trường hợp cần lưu 1 mảng các thứ có kiểu khác nhau. May mắn thay, các kiểu con
của enum đều được định nghĩa dưới cùng 1 kiểu enum. Khi chung ta cần lưu trữ phần
tử với những kiểu dữ liệu khác nhau, chúng ta có thể định nghĩa và sử dụng enum!</p>
<p>Ví dụ, cho rằng chúng ta muốn lấy giá trị trong 1 dòng của bảng tính, nơi mà
1 số cột chứa số nguyên, 1 số chứa số thực, và 1 số chứa chuỗi. Chúng ta có thể
định nghĩa tất cả biến thể của enum và giữ các kiểu giá trị khác nhau, khi đó tất cả
biến thể của enum đều được xem là cùng 1 kiểu. Như vậy chúng ta có thể tạo ra một
vector giữ những enum đó và, cuối cùng, giữ các kiểu dữ liệu khác nhau:</p>
<pre><code class="language-rust">enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
</code></pre>
<p>Lý do mà Rust cần biết chính xác kiểu dữ liệu nào sẽ được chứa trong vector tại
thời điểm biên dịch (compile time) là vì nó cần biết chính xác bao nhiêu không gian
trong bộ nhớ Heap cần để chứa mỗi phần tử. Lợi điểm thứ 2 của việc này là chúng ta
có thể giới hạn những kiểu dữ liệu được chứa trong vector. Nếu Rust cho phép vector
có thể giữ bất kì kiểu dữ liệu nào, sẽ có khả năng một hay nhiều kiểu dữ liệu sẽ
gây ra lỗi khi chúng ta thực thi các hàm không tương thích. Sử dụng kết hợp enum và
<code>match</code> có nghĩa là Rust có thể đảm bảo ở compile time là chúng ta luôn luôn xử lý
tất cả trường hợp có thể xảy ra, như chúng ta đã thảo luận ở Chương 6.</p>
<!-- Can you briefly explain what the match is doing here, as a recap? How does
it mean we always handle every possible case? I'm not sure it's totally clear.
-->
<!-- Because this is a focus of chapter 6 rather than this chapter's focus, we
don't think we should repeat it here as well, but we added a reference. /Carol
-->
<p>Nếu tại thời điểm viết chương trình bạn không biết tất cả những kiểu dữ liệu có thể
sẽ được chứa trong vector lúc nó được chạy, kĩ thuật dùng enum sẽ không hoạt động.
Thay vào đó, bạn có thể sử dụng trait object, chúng ta sẽ tìm hiểu về nó trong
Chương 13.</p>
<p>Sau khi chúng ta đã tìm hiểu qua một số những cách thông dụng nhất để sử dụng vector,
hãy đảm bảo là bạn sẽ xem qua tài liệu API (API documentation) để biết tất cả những
hàm hữu ích được viết trong module <code>Vec</code> của thư viện chuẩn. Ví dụ, ngoài <code>push</code> còn
có hàm <code>pop</code> sẽ giúp bạn xoá và lấy ra phần tử cuối cùng trong vector. Bây giờ, hãy
cùng qua tới kiểu dữ liệu tập hợp tiếp theo: <code>String</code>!</p>
<p>Now that we've gone over some of the most common ways to use vectors, be sure
to take a look at the API documentation for all of the many useful methods
defined on <code>Vec</code> by the standard library. For example, in addition to <code>push</code>
there's a <code>pop</code> method that will remove and return the last element. Let's move
on to the next collection type: <code>String</code>!</p>
<!-- Do you mean the Rust online documentation here? Are you not including it
in the book for space reasons? We might want to justify sending them out of the
book if we don't want to cover it here -->
<!-- Yes, there are many, many methods on Vec: https://doc.rust-lang.org/stable/std/vec/struct.Vec.html
Also there are occcasionally new methods available with new versions of the
language, so there's no way we can be comprehensive here. We want the reader to
use the API documentation in these situations since the purpose of the online
docs is to be comprehensive and up to date. I personally wouldn't expect a book
like this to duplicate the info that's in the API docs, so I don't think a
justification is necessary here. /Carol  -->

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
