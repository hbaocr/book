<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Ngôn ngữ lập trình Rust</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="ch01-00-introduction.html"><strong>1.</strong> Introduction</a></li><li><ul class="section"><li><a href="ch01-01-installation.html"><strong>1.1.</strong> Installation</a></li><li><a href="ch01-02-hello-world.html"><strong>1.2.</strong> Hello, World!</a></li></ul></li><li><a href="ch02-00-guessing-game-tutorial.html"><strong>2.</strong> Guessing Game Tutorial</a></li><li><a href="ch03-00-common-programming-concepts.html"><strong>3.</strong> Common Programming Concepts</a></li><li><ul class="section"><li><a href="ch03-01-variables-and-mutability.html"><strong>3.1.</strong> Variables and Mutability</a></li><li><a href="ch03-02-data-types.html"><strong>3.2.</strong> Data Types</a></li><li><a href="ch03-03-how-functions-work.html"><strong>3.3.</strong> How Functions Work</a></li><li><a href="ch03-04-comments.html"><strong>3.4.</strong> Comments</a></li><li><a href="ch03-05-control-flow.html"><strong>3.5.</strong> Control Flow</a></li></ul></li><li><a href="ch04-00-understanding-ownership.html"><strong>4.</strong> Understanding Ownership</a></li><li><ul class="section"><li><a href="ch04-01-what-is-ownership.html"><strong>4.1.</strong> What is Ownership?</a></li><li><a href="ch04-02-references-and-borrowing.html"><strong>4.2.</strong> References &amp; Borrowing</a></li><li><a href="ch04-03-slices.html"><strong>4.3.</strong> Slices</a></li></ul></li><li><a href="ch05-00-structs.html"><strong>5.</strong> Structs</a></li><li><ul class="section"><li><a href="ch05-01-method-syntax.html"><strong>5.1.</strong> Method Syntax</a></li></ul></li><li><a href="ch06-00-enums.html"><strong>6.</strong> Enums</a></li><li><ul class="section"><li><a href="ch06-01-option.html"><strong>6.1.</strong> Option</a></li><li><a href="ch06-02-match.html"><strong>6.2.</strong> Match</a></li><li><a href="ch06-03-if-let.html"><strong>6.3.</strong> <code>if let</code></a></li></ul></li><li><a href="ch07-00-modules.html"><strong>7.</strong> Modules</a></li><li><ul class="section"><li><a href="ch07-01-mod-and-the-filesystem.html"><strong>7.1.</strong> <code>mod</code> and the Filesystem</a></li><li><a href="ch07-02-controlling-visibility-with-pub.html"><strong>7.2.</strong> Controlling Visibility with <code>pub</code></a></li><li><a href="ch07-03-importing-names-with-use.html"><strong>7.3.</strong> Importing Names with <code>use</code></a></li></ul></li><li><a href="ch08-00-fundamental-collections.html"><strong>8.</strong> Fundamental Collections</a></li><li><ul class="section"><li><a href="ch08-01-vectors.html"><strong>8.1.</strong> Vectors</a></li><li><a href="ch08-02-strings.html"><strong>8.2.</strong> Strings</a></li><li><a href="ch08-03-hash-maps.html"><strong>8.3.</strong> Hash Maps</a></li></ul></li><li><a href="ch09-00-error-handling.html"><strong>9.</strong> Error Handling</a></li><li><ul class="section"><li><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong>9.1.</strong> Unrecoverable Errors with <code>panic!</code></a></li><li><a href="ch09-02-recoverable-errors-with-result.html" class="active"><strong>9.2.</strong> Recoverable Errors with <code>Result</code></a></li><li><a href="ch09-03-to-panic-or-not-to-panic.html"><strong>9.3.</strong> To <code>panic!</code> or Not To <code>panic!</code></a></li></ul></li><li><a href="ch10-00-generics.html"><strong>10.</strong> Generics</a></li><li><ul class="section"><li><a href="ch10-01-syntax.html"><strong>10.1.</strong> Syntax</a></li><li><a href="ch10-02-traits.html"><strong>10.2.</strong> Traits</a></li><li><a href="ch10-03-lifetime-syntax.html"><strong>10.3.</strong> Lifetime syntax</a></li></ul></li><li><a href="ch11-00-testing.html"><strong>11.</strong> Testing</a></li><li><ul class="section"><li><a href="ch11-01-writing-tests.html"><strong>11.1.</strong> Writing tests</a></li><li><a href="ch11-02-running-tests.html"><strong>11.2.</strong> Running tests</a></li><li><a href="ch11-03-test-organization.html"><strong>11.3.</strong> Test Organization</a></li></ul></li><li><strong>12.</strong> I/O</li><li><ul class="section"><li><strong>12.1.</strong> <code>Read</code> &amp; <code>Write</code></li><li><strong>12.2.</strong> <code>std::fs</code></li><li><strong>12.3.</strong> <code>std::path</code></li><li><strong>12.4.</strong> <code>std::env</code></li></ul></li><li><strong>13.</strong> Composition</li><li><ul class="section"><li><strong>13.1.</strong> Instead of Inheritance</li><li><strong>13.2.</strong> Trait Objects?</li></ul></li><li><strong>14.</strong> Creating a Library</li><li><ul class="section"><li><strong>14.1.</strong> Cargo</li><li><strong>14.2.</strong> Crates.io</li><li><a href="chYY-YY-public-api.html"><strong>14.3.</strong> Organizing your Public API</a></li><li><a href="chYY-YY-documentation.html"><strong>14.4.</strong> Documentation</a></li><li><a href="chYY-YY-workspaces.html"><strong>14.5.</strong> Workspaces and Multiple Related Crates</a></li></ul></li><li><strong>15.</strong> Closures</li><li><strong>16.</strong> Zero-cost Abstractions</li><li><ul class="section"><li><strong>16.1.</strong> Iterators as a Case Study</li></ul></li><li><strong>17.</strong> Smart Pointers</li><li><ul class="section"><li><strong>17.1.</strong> <code>Box&lt;T&gt;</code></li><li><strong>17.2.</strong> <code>Rc&lt;T&gt;</code></li><li><strong>17.3.</strong> <code>Cell</code></li><li><strong>17.4.</strong> <code>RefCell</code></li><li><strong>17.5.</strong> Interior Mutability</li></ul></li><li><strong>18.</strong> Concurrency</li><li><ul class="section"><li><strong>18.1.</strong> Threads</li><li><strong>18.2.</strong> <code>Send</code> &amp; <code>Sync</code></li><li><strong>18.3.</strong> <code>Arc&lt;T&gt;</code></li><li><strong>18.4.</strong> <code>Mutex&lt;T&gt;</code></li><li><strong>18.5.</strong> <code>Channels</code></li></ul></li><li><a href="chXX-patterns.html"><strong>19.</strong> Patterns</a></li><li><strong>20.</strong> More Lifetimes</li><li><strong>21.</strong> Unsafe Rust</li><li><ul class="section"><li><strong>21.1.</strong> Raw Pointers</li><li><strong>21.2.</strong> <code>transmute</code></li></ul></li><li><strong>22.</strong> Foreign Function Interface</li><li><ul class="section"><li><strong>22.1.</strong> Conditional Compilation</li><li><strong>22.2.</strong> Bindings to C</li><li><strong>22.3.</strong> Using Rust from Other Languages</li><li><strong>22.4.</strong> <code>static</code></li></ul></li><li><strong>23.</strong> Advanced Type System Features</li><li><ul class="section"><li><strong>23.1.</strong> Associated Types</li><li><strong>23.2.</strong> Trait Objects</li><li><strong>23.3.</strong> UFCS</li><li><strong>23.4.</strong> Coherence</li></ul></li><li><strong>24.</strong> Macros</li><li><ul class="section"><li><strong>24.1.</strong> Writing Your Own Macros</li></ul></li><li><strong>25.</strong> Nightly Rust</li><li><ul class="section"><li><strong>25.1.</strong> Nightly Features</li><li><strong>25.2.</strong> How to Find Out About Nightly Features</li></ul></li><li><a href="appendix-00.html"><strong>26.</strong> Appendix</a></li><li><ul class="section"><li><a href="appendix-01-keywords.html"><strong>26.1.</strong> Keywords</a></li><li><a href="appendix-02-operators.html"><strong>26.2.</strong> Operators</a></li><li><a href="appendix-03-derivable-traits.html"><strong>26.3.</strong> Derivable Traits</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">Ngôn ngữ lập trình Rust</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h2>Recoverable Errors with <code>Result</code></h2>
<p>Most errors aren't so dire. Sometimes, when a function fails, it's for a reason
that we can easily interpret and respond to. As an example, maybe we are making
a request to a website, but it's down for maintenance. In this situation, we'd
like to wait and then try again. Terminating our process isn't the right thing
to do here.</p>
<p>In these cases, Rust's standard library provides an <code>enum</code> to use as the return
type of the function:</p>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
</code></pre>
<p>The <code>Ok</code> variant indicates a successful result, and <code>Err</code> indicates an
unsuccessful result. These two variants each contain one thing: in <code>Ok</code>'s case,
it's the successful return value. With <code>Err</code>, it's some value that represents
the error. The <code>T</code> and <code>E</code> are generic type parameters; we'll go into generics
in more detail in Chapter 10. What you need to know for right now is that the
<code>Result</code> type is defined such that it can have the same behavior for any type
<code>T</code> that is what we want to return in the success case, and any type <code>E</code> that
is what we want to return in the error case.</p>
<p>Listing 9-2 shows an example of something that might fail: opening a file.</p>
<figure>
<span class="filename">Filename: src/main.rs</span>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre>
<figcaption>
<p>Listing 9-2: Opening a file</p>
</figcaption>
</figure>
<p>The type of <code>f</code> in this example is a <code>Result</code>, because there are many ways in
which opening a file can fail. For example, unless we created <code>hello.txt</code>, this
file does not yet exist. Before we can do anything with our <code>File</code>, we need to
extract it out of the result. Listing 9-3 shows one way to handle the <code>Result</code>
with a basic tool: the <code>match</code> expression that we learned about in Chapter 6.</p>
<!-- I'll ghost everything except the match statement lines in the libreoffice file /Carol -->
<figure>
<span class="filename">Filename: src/main.rs</span>
<pre><code class="language-rust,should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;There was a problem opening the file: {:?}&quot;,
error),
    };
}
</code></pre>
<figcaption>
<p>Listing 9-3: Using a <code>match</code> expression to handle the <code>Result</code> variants we
might have</p>
</figcaption>
</figure>
<p>If we see an <code>Ok</code>, we can return the inner <code>file</code> out of the <code>Ok</code> variant. If
we see <code>Err</code>, we have to decide what to do with it. The simplest thing is to
turn our error into a <code>panic!</code> instead, by calling the macro. And since we
haven't created that file yet, we'll see a message indicating as such when we
print the error value:</p>
<pre><code class="language-text">thread 'main' panicked at 'There was a problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:8
</code></pre>
<h3>Matching on Different Errors</h3>
<p>There are many reasons why opening a file might fail, and we may not want to
take the same actions to try to recover for all of them. For example, if the
file we're trying to open does not exist, we could choose to create it. If the
file exists but we don't have permission to read it, or any other error, we
still want to <code>panic!</code> in the same way as above and not create the file.</p>
<p>The <code>Err</code> type <code>File::open</code> returns is <a href="../std/io/struct.Error.html"><code>io::Error</code></a><!-- ignore -->,
which is a struct provided by the standard library. This struct has a method
<code>kind</code> that we can call to get an <a href="../std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a><!-- ignore -->
value that we can use to handle different causes of an <code>Err</code> returned from
<code>File::open</code> differently as in Listing 9-4:</p>
<figure>
<span class="filename">Filename: src/main.rs</span>
<pre><code class="language-rust,ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(ref error) if error.kind() == ErrorKind::NotFound =&gt; {
            match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Tried to create file but there was a problem: {:?}&quot;, e),
            }
        },
        Err(error) =&gt; panic!(&quot;There was a problem opening the file: {:?}&quot;,
error),
    };
}
</code></pre>
<figcaption>
<p>Listing 9-4: Handling different kinds of errors in different ways</p>
</figcaption>
</figure>
<!-- I will add ghosting and wingdings here in libreoffice /Carol -->
<p>This example uses a <em>match guard</em> with the second arm's pattern to add a
condition that further refines the pattern. The <code>ref</code> in the pattern is needed
so that the <code>error</code> is not moved into the guard condition. The condition we
want to check is that the value <code>error.kind()</code> returns is the <code>NotFound</code>
variant of the <code>ErrorKind</code> enum. Note that <code>File::create</code> could also fail, so
we need to add an inner <code>match</code> statement as well! The last arm of the outer
<code>match</code> stays the same to panic on any error besides the file not being found.</p>
<h3>Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code></h3>
<p>Using <code>match</code> works okay but can be a bit verbose, and it doesn't always
communicate intent well. The <code>Result&lt;T, E&gt;</code> type has many helper methods
defined on it to do various things. &quot;Panic on an error result&quot; is one of those
methods, and it's called <code>unwrap()</code>:</p>
<!-- I'll ghost everything except `unwrap()` in the libreoffice file /Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust,should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre>
<p>This has similar behavior as the example using <code>match</code> in Listing 9-3: If the
call to <code>open()</code> returns <code>Ok</code>, return the value inside. If it's an <code>Err</code>, panic.</p>
<p>There's also another method that is similar to <code>unwrap()</code>, but lets us choose
the error message: <code>expect()</code>. Using <code>expect()</code> instead of <code>unwrap()</code> and
providing good error messages can convey your intent and make tracking down the
source of a panic easier. <code>expect()</code> looks like this:</p>
<!-- I'll ghost everything except `expect()` in the libreoffice file /Carol -->
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust,should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt.&quot;);
}
</code></pre>
<p>This isn't the only way to deal with errors, however. This entire section is
supposed to be about recovering from errors, but we've gone back to panic. This
observation gets at an underlying truth: you can easily turn a recoverable
error into an unrecoverable one with <code>unwrap()</code> or <code>expect()</code>, but you can't
turn an unrecoverable <code>panic!</code> into a recoverable one. This is why good Rust
code chooses to make errors recoverable: you give your caller choices.</p>
<p>The Rust community has a love/hate relationship with <code>unwrap()</code> and <code>expect()</code>.
They're very handy when prototyping, before you're ready to decide how to
handle errors, and in that case they leave clear markers to look for when you
are ready to make your program more robust. They're useful in tests since they
will cause the test to fail if there's an error any place you call them. In
examples, you might not want to muddy the code with proper error handling. But
if you use them in a library, mis-using your library can cause other people's
programs to halt unexpectedly, and that's not very user-friendly.</p>
<p>Another time it's appropriate to call <code>unwrap</code> is when we have some other logic
that ensures the <code>Result</code> will have an <code>Ok</code> value, but the logic isn't
something the compiler understands. If you can ensure by manually inspecting
the code that you'll never have an <code>Err</code> variant, it is perfectly acceptable to
call <code>unwrap</code>. Here's an example:</p>
<pre><code class="language-rust">use std::net::IpAddr;

let home = &quot;127.0.0.1&quot;.parse::&lt;IpAddr&gt;().unwrap();
</code></pre>
<p>We're creating an <code>IpAddr</code> instance by parsing a hardcoded string. We can see
that <code>&quot;127.0.0.1&quot;</code> is a valid IP address, so it's acceptable to use <code>unwrap</code>
here. If we got the IP address string from a user of our program instead of
hardcoding this value, we'd definitely want to handle the <code>Result</code> in a more
robust way instead.</p>
<h3>Propagating errors with <code>try!</code> or <code>?</code></h3>
<p>When writing a function, if you don't want to handle the error where you are,
you can return the error to the calling function. For example, Listing 9-5
shows a function that reads a username from a file. If the file doesn't exist
or can't be read, this function will return those errors to the code that
called this function:</p>
<figure>
<pre><code class="language-rust"># use std::fs::File;
# use std::io;
# use std::io::Read;
#
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
</code></pre>
<figcaption>
<p>Listing 9-5: A function that returns errors to the calling code using <code>match</code></p>
</figcaption>
</figure>
<p>Since the <code>Result</code> type has two type parameters, we need to include them both
in our function signature. In this case, <code>File::open</code> and <code>read_to_string</code>
return <code>std::io::Error</code> as the value inside the <code>Err</code> variant, so we will also
use it as our error type. If this function succeeds, we want to return the
username as a <code>String</code> inside the <code>Ok</code> variant, so that is our success type.</p>
<p>This is a very common way of handling errors: propagate them upward until
you're ready to deal with them. This pattern is so common in Rust that there is
a macro for it, <code>try!</code>, and as of Rust 1.14 <!-- 1.14 has not been released as
a stable version yet, but that's the version the question mark operator will be
released in /Carol -->, dedicated syntax for it: the question mark
operator. We could have written the code in Listing 9-5 using the <code>try!</code> macro,
as in Listing 9-6, and it would have the same functionality as the <code>match</code>
expressions:</p>
<!-- I'll ghost everything except the calls to `try!` in the libreoffice file
/Carol -->
<figure>
<pre><code class="language-rust"># use std::fs::File;
# use std::io;
# use std::io::Read;
#
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = try!(File::open(&quot;hello.txt&quot;));
    let mut s = String::new();

    try!(f.read_to_string(&amp;mut s));

    Ok(s)
}
</code></pre>
<figcaption>
<p>Listing 9-6: A function that returns errors to the calling code using <code>try!</code></p>
</figcaption>
</figure>
<p>Or as in Listing 9-7, which uses the question mark operator:</p>
<figure>
<pre><code class="language-rust"># fn main() {}
# use std::fs::File;
# use std::io;
# use std::io::Read;
#
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<figcaption>
<p>Listing 9-7: A function that returns errors to the calling code using <code>?</code></p>
</figcaption>
</figure>
<p>The <code>?</code> operator at the end of the <code>open</code> call does the same thing as the
example that uses <code>match</code> and the example that uses the <code>try!</code> macro: It will
return the value inside an <code>Ok</code> to the binding <code>f</code>, but will return early out
of the whole function and give any <code>Err</code> value we get to our caller. The same
thing applies to the <code>?</code> at the end of the <code>read_to_string</code> call.</p>
<p>The advantage of using the question mark operator over the <code>try!</code> macro is the
question mark operator permits chaining. We could further shorten this code
by instead doing:</p>
<pre><code class="language-rust"># fn main() {}
# use std::fs::File;
# use std::io;
# use std::io::Read;
#
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
</code></pre>
<p>Much nicer, right? The <code>try!</code> macro and the <code>?</code> operator make propagating
errors upwards much more ergonomic. There's one catch though: they can only be
used in functions that return a <code>Result</code>, since they expand to the same <code>match</code>
expression we saw above that had a potential early return of an <code>Err</code> value.
Let's look at what happens if we try to use <code>try!</code> in the <code>main</code> function,
which you'll recall has a return type of <code>()</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust,ignore"># use std::fs::File;
fn main() {
    let f = try!(File::open(&quot;hello.txt&quot;));
}
</code></pre>
<!-- NOTE: as of 2016-10-12, the error message when calling `?` in a function
that doesn't return a result is confusing. `try!` isn't as bad, so I'm using
that. When https://github.com/rust-lang/rust/issues/35946 is fixed, we can
switch this example to use `?`. /Carol -->
<p>When we compile this, we get the following error message:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt;
  |
3 |     let f = try!(File::open(&quot;hello.txt&quot;));
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected (), found enum `std::result::Result`
  |
  = note: expected type `()`
  = note:    found type `std::result::Result&lt;_, _&gt;`
</code></pre>
<p>The mismatched types that this error is pointing out says the <code>main()</code> function
has a return type of <code>()</code>, but the <code>try!</code> macro might return a <code>Result</code>. So in
functions that don't return <code>Result</code>, when you call other functions that return
<code>Result</code>, you'll need to use a <code>match</code> or one of the methods on <code>Result</code> to
handle it instead of using <code>try!</code> or <code>?</code>.</p>
<p>Now that we've discussed the details of calling <code>panic!</code> or returning <code>Result</code>,
let's return to the topic of how to decide which is appropriate in which cases.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="ch09-01-unrecoverable-errors-with-panic.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch09-03-to-panic-or-not-to-panic.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="ch09-01-unrecoverable-errors-with-panic.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="ch09-03-to-panic-or-not-to-panic.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
